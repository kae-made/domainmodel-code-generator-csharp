<#
  // Copyright (c) Knowledge & Experience. All rights reserved.
  // Licensed under the MIT license. See LICENSE file in the project root for full license information.
#>
<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Kae.CIM.MetaModel.CIMofCIM" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This file is generated by tool.
//     Runtime Version : <#= version #>
//  
// </auto-generated>
// ------------------------------------------------------------------------------
using Kae.DomainModel.Csharp.Framework;
using Kae.DomainModel.Csharp.Framework.Adaptor;
using Kae.Utility.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace <#= nameSpace #>.Adaptor
{
    // Entry for Application front end.
    public static class DomainModelAdaptorEntry
    {
        public static DomainModelAdaptor GetAdaptor(Logger logger) { return <#= nameSpace #>Adaptor.GetInstance(logger); }
    }

<#
    Initialize();

    string domainFacadeClassName = GeneratorNames.GetDomainFacadeClassName(nameSpace);
    string adaptorName = $"{nameSpace}Adaptor";
#>
    public class <#= adaptorName #> : DomainModelAdaptor
    {
        <#= domainFacadeClassName #> domainModel;

        public static DomainModelAdaptor adapterInstance = null;

        public static DomainModelAdaptor GetInstance(Logger logger)
        {
            if (adapterInstance == null)
            {
                var instanceRepository = new InstanceRepositoryInMemory(logger);
                var cimLib = new CIMProcessManagementLib(instanceRepository);
                adapterInstance = new <#= adaptorName #>(cimLib, logger);
            }
            return adapterInstance;
        }


        public <#= adaptorName #>(<#= domainFacadeClassName#> domainModel, Logger logger) : base(logger)
        {
            this.domainModel = domainModel;
            domainOpsParamSpecs = _domainOpsParamSpecs;
            classSpecs = _classSpecs;
            domainModelName = "<#= nameSpace #>";
        }

<#
    var sb = new StringBuilder();
    indent = "        ";
    var writer = new StringWriter(sb);
    string currentIndent = $"{indent}{baseIndent}";

    // domain operation dictionary generation
#>
        protected Dictionary<string, Dictionary<string, ParamSpec>> _domainOpsParamSpecs = new Dictionary<string, Dictionary<string, ParamSpec>>()
        {
<#
    int syncCount = 1;
    foreach (var syncSpecKey in domainOpSpecs.Keys)
    {
        var syncSpec = domainOpSpecs[syncSpecKey];
#>
            {
                "<#= syncSpecKey #>", new Dictionary<string, ParamSpec>()
<#
        if (syncSpec.Parameters.Count > 0)
        {
#>
                {
<#
        int paramCount = 1;
        foreach (var paramSpecKey in syncSpec.Parameters.Keys) {
            var paramSpec = syncSpec.Parameters[paramSpecKey];
            string code = GetParamSpecCreateCode(paramSpec);
#>
                    { "<#= paramSpecKey #>", <#= code #> }<# if (paramCount < syncSpec.Parameters.Count) { #>,<# } #>

<#
            paramCount++;
        }
#>
                }
<#
        }
#>
            }<# if (syncCount < domainOpSpecs.Count) { #>,<# } #>

<#
        syncCount++;
    }
#>
        };

<#
    // dictionaly class spec
#>
        protected Dictionary<string, ClassSpec> _classSpecs = new Dictionary<string, ClassSpec>()
        {
<#
    int classCount = 1;
    foreach (var classSpecKey in classSpecs.Keys)
    {
        var classSpec = classSpecs[classSpecKey];
#>
            {
                "<#= classSpec.KeyLetter #>", new ClassSpec()
                {                
                    Name = "<#= classSpec.Name #>",
                    KeyLetter = "<#= classSpec.KeyLetter #>",
                    Properties = new Dictionary<string, PropSpec>()<# if (classSpec.Properties.Count > 0) { #>

                    {
<#
        int itemCount = 1;
        foreach (var propKey in classSpec.Properties.Keys)
        {
            var prop = classSpec.Properties[propKey];
#>
                        {
                            "<#= prop.Name #>", new PropSpec()
                            { Name = "<#= prop.Name #>", DataType = ParamSpec.DataType.<#= prop.DataType.ToString() #>, Identity = <#= prop.Identity #>, Writable = <#= prop.Writable.ToString().ToLower() #>, Mathematical = <#= prop.Mathematical.ToString().ToLower() #>, Reference = <#= prop.Reference.ToString().ToLower() #>, StateMachineState = <#= prop.StateMachineState.ToString().ToLower() #> }
                        }<# if (itemCount < classSpec.Properties.Count) { #>,<# } #>

<#
            itemCount++;
        }
#>
                    }<# } #>,
                    Operations = new Dictionary<string, OperationSpec>()<# if (classSpec.Operations.Count > 0) { #>

                    {
<#
        int itemCount = 1;
        foreach (var opKey in classSpec.Operations.Keys)
        {
            var op = classSpec.Operations[opKey];
#>
                        {
                            "<#= op.Name #>", new OperationSpec()
                            {
                                Name = "<#= op.Name #>", ReturnType = ParamSpec.DataType.<#= op.ReturnType #>, Parameters = new Dictionary<string, ParamSpec>()
<#
            if (op.Parameters.Count > 0)
            {
                int opParamCount = 1;
#>
                                {
<#
                foreach (var opParamKey in op.Parameters.Keys)
                {
                    var opParam = op.Parameters[opParamKey];
                    string code = GetParamSpecCreateCode(opParam);
#>
                                    { "<#= opParam.Name #>", <#= code #> }<# if (opParamCount < op.Parameters.Count) { #>,<# } #>

<#

                    opParamCount++;
                }
#>
                                }
<#
            }
#>
                            }<# if (itemCount < classSpec.Operations.Count) { #>,<# } #>

                        }
<#

            itemCount++;
        }
#>
                    }<# } #>,
                    Links = new Dictionary<string, LinkSpec>()<# if (classSpec.Links.Count > 0) { #>

                    {
<#
        int itemCount = 1;
        foreach (var linkKey in classSpec.Links.Keys)
        {
            var link = classSpec.Links[linkKey];
#>
                        {
                            "<#= link.Name #>", new LinkSpec()
                            { Name = "<#= link.Name #>", RelID = "<#= link.RelID #>", Phrase = "<#= link.Phrase #>", Set = <#= link.Set.ToString().ToLower() #>, Condition = <#= link.Condition.ToString().ToLower() #>, DstKeyLett = "<#= link.DstKeyLett #>" }
                        }<# if (itemCount < classSpec.Links.Count) { #>,<# } #>

<#

            itemCount++;
        }
#>
                    }<# } #>,
                    Events = new Dictionary<string, OperationSpec>()<# if (classSpec.Events.Count > 0) { #>

                    {
<#
        int itemCount = 1;
        foreach (var eventKey in classSpec.Events.Keys)
        {
            var eventSpec = classSpec.Events[eventKey];
#>
                        {
                            "<#= eventSpec.Name #>", new OperationSpec()
                            {
                                Name = "<#= eventSpec.Name #>", ReturnType = ParamSpec.DataType.Void, Parameters = new Dictionary<string, ParamSpec>()<# if (eventSpec.Parameters.Count > 0) { #>

                                {
<#
            int evtParamCount = 1;
            foreach (var epKey in eventSpec.Parameters.Keys)
            {
                var evtParam = eventSpec.Parameters[epKey];
                string code = GetParamSpecCreateCode(evtParam);
#>
                                    { "<#= evtParam.Name #>", <#= code #> }<# if (evtParamCount < eventSpec.Parameters.Count) { #>, <# } #>

<#
                evtParamCount++;
            }
#>
                                }
<# } else { #>

<# } #>
                            }
                        }<# if (itemCount < classSpec.Events.Count) { #>,<# } #>

<#

            itemCount++;
        }
#>
                    }<# } #>

                }
            }<# if (classCount < classSpecs.Count) { #>,<# } #>

<#
        classCount++;        
    }
#>
        };

<#
    // Invoke Domain Operation
    string invVarName = "invSpec";
#>
        public override string InvokeDomainOperation(string name, RequestingParameters parameters)
        {
            string result = "{}";
            if (domainOpsParamSpecs.ContainsKey(name))
            {
                var opSpec = domainOpsParamSpecs[name];
                RequestingParameters invSpec = new RequestingParameters() { Parameters = new Dictionary<string, object>() };
                if (CheckParameters(opSpec, parameters, <#= invVarName #>))
                {
                    switch (name)
                    {
<#
    foreach (var syncSpecKey in domainOpSpecs.Keys)
    {
        var syncSpec = domainOpSpecs[syncSpecKey];
        string paramCode = GetInvokeParamsCode(syncSpec.Parameters, invVarName);
        string invokeCode = $"domainModel.{syncSpec.Name}({paramCode})";
        string retVal = $"resultOf{syncSpec.Name}";
#>
                        case "<#= syncSpec.Name  #>":
<#
        if (syncSpec.ReturnType != ParamSpec.DataType.Void)
        {
#>
                            var <#= retVal #> = new { result = <#= invokeCode #> };
                            result = Newtonsoft.Json.JsonConvert.SerializeObject(<#= retVal #>);
<#
        }
        else
        {
#>
                            <#= invokeCode #>;
<#
        }
#>
                            break;
<#
    }
#>
                    }
                }
            }

            return result;
        }

        public override string InvokeDomainClassOperation(string classKeyLett, string name, RequestingParameters parameters)
        {
            string result = "{}";
            if (classSpecs.ContainsKey(classKeyLett))
            {
                var classSpec = classSpecs[classKeyLett];
                if (classSpec.Operations.ContainsKey(name))
                {
                    var opSpec = classSpec.Operations[name];
                    var invSpec = new RequestingParameters() { Parameters = new Dictionary<string, object>(), Identities = new Dictionary<string, string>() };
                    if (CheckIdentity(classSpec.Properties, parameters, invSpec))
                    {
                        if(CheckParameters(opSpec.Parameters,parameters, invSpec))
                        {
                            switch (classKeyLett)
                            {
<#
    foreach(var csKey in classSpecs.Keys)
    {
        var classSpec = classSpecs[csKey];
        if (classSpec.Operations.Count > 0)
        {
            string domainClassName = GeneratorNames.GetDomainClassName(classSpec.ObjDef);
            string classKeyLett = classSpec.KeyLetter;
            string instVarName = $"instanceOf{classKeyLett}";
            string instSelectedCode = GetSelectedByIdentitiesCode(domainClassName, "selected", invVarName + ".Identities", classSpec.Properties);
#>
                                case "<#= classKeyLett #>":
                                    var <#= instVarName #> = (<#= domainClassName #>)domainModel.InstanceRepository.GetDomainInstances("<#= classKeyLett #>").Where(<#= instSelectedCode #>).FirstOrDefault();
                                    if (<#= instVarName #> != null)
                                    {
                                        switch (name)
                                        {
<#
            foreach (var copKey in classSpec.Operations.Keys)
            {
                var cOpSpec = classSpec.Operations[copKey];
                string paramCode = GetInvokeParamsCode(cOpSpec.Parameters, invVarName);
                string invokeCode = $"{instVarName}.{cOpSpec.Name}({paramCode})";
                string retVal = $"resultOf{cOpSpec.Name}";

#>
                                            case "<#= cOpSpec.Name #>":
<#
        if (cOpSpec.ReturnType == ParamSpec.DataType.Void)
        {
#>
                                                <#= invokeCode #>;
<#
        }
        else
        {
#>
                                                 var <#= retVal #> = new { result = <#= invokeCode #> };
                                                result = Newtonsoft.Json.JsonConvert.SerializeObject(<#= retVal #>);
<#
        }
#>
                                                break;
<#
            }
#>
                                        }
                                    }
                                    break;
<#
        }
    }
#>
                            }
                        }
                    }

                }
            }

            return result;
        }

        public override string SendEvent(string classKeyLett, string name, RequestingParameters parameters)
        {
            bool sent = false;
            if (classSpecs.ContainsKey(classKeyLett))
            {
                var classSpec = classSpecs[classKeyLett];
                if (classSpec.Events.ContainsKey(name))
                {
                    var evtSpec = classSpec.Events[name];
                    var invSpec = new RequestingParameters() { Parameters = new Dictionary<string, object>(), Identities = new Dictionary<string, string>() };
                    if (CheckIdentity(classSpec.Properties, parameters, invSpec))
                    {
                        if(CheckParameters(evtSpec.Parameters,parameters, invSpec))
                        {
                            switch (classKeyLett)
                            {
<#
    foreach(var csKey in classSpecs.Keys)
    {
        var classSpec = classSpecs[csKey];
        if (classSpec.Events.Count > 0)
        {
            string domainClassName = GeneratorNames.GetDomainClassName(classSpec.ObjDef);
            string classKeyLett = classSpec.KeyLetter;
            string instVarName = $"instanceOf{classKeyLett}";
            string instSelectedCode = GetSelectedByIdentitiesCode(domainClassName, "selected", invVarName + ".Identities", classSpec.Properties);
#>
                                case "<#= classKeyLett #>":
                                    var <#= instVarName #> = (<#= domainClassName #>)domainModel.InstanceRepository.GetDomainInstances("<#= classKeyLett #>").Where(<#= instSelectedCode #>).FirstOrDefault();
                                    switch (name)
                                    {
<#
            foreach(var evtKey in classSpec.Events.Keys)
            {
                var evtSpec = classSpec.Events[evtKey];
                string stateMachineClassName = GeneratorNames.GetStateMachineClassName(classSpec.ObjDef);
                string evtClassName = GeneratorNames.GetEventClassName(classSpec.ObjDef, evtSpec.EvtDef);
                string evtCreateMethodName = $"{stateMachineClassName}.{evtClassName}.Create";
                string paramCode = GetInvokeParamsCode(evtSpec.Parameters, invVarName);
                if (!string.IsNullOrEmpty(paramCode))
                {
                    paramCode = $", {paramCode}";
                }
                paramCode += ", sendNow:true";
                if (evtSpec.CreationEvent)
                {
                    paramCode += ", domainModel.InstanceRepository, logger:logger";
                }
                string evtInvCode = $"{evtCreateMethodName}({instVarName}{paramCode})";
#>
                                        case "<#= evtClassName #>":
                                            <#= evtInvCode #>;
                                            sent = true;
                                            break;
<#
            }
#>
                                    }
                                    break;
<#
        }
    }
#>
                            }
                        }
                    }
                }
            }
            var result = new { sent = sent };
            return Newtonsoft.Json.JsonConvert.SerializeObject(result);
        }

        public override string UpdateClassProperties(string classKeyLett, RequestingParameters parameters)
        {
            bool updated = false;
            if (classSpecs.ContainsKey(classKeyLett))
            {
                var classSpec = classSpecs[classKeyLett];
                var invSpec = new RequestingParameters() { Parameters = new Dictionary<string, object>(), Identities = new Dictionary<string, string>() };
                if (CheckProperties(classSpec.Properties, parameters, invSpec))
                {
                    switch (classKeyLett)
                    {
<#
        foreach (var ck in classSpecs.Keys)
        {
            var classSpec = classSpecs[ck];
            string domainClassName = GeneratorNames.GetDomainClassName(classSpec.ObjDef);
            string classKeyLett = classSpec.KeyLetter;
            string instVarName = $"instanceOf{classKeyLett}";
            string instSelectedCode = GetSelectedByIdentitiesCode(domainClassName, "selected", invVarName + ".Identities", classSpec.Properties);
            if (classSpec.NumOfWritableProperties > 0)
            {
#>
                        case "<#= classKeyLett #>":
                            var <#= instVarName #> = (<#= domainClassName #>)domainModel.InstanceRepository.GetDomainInstances("<#= classKeyLett #>").Where(<#= instSelectedCode #>).FirstOrDefault();
                            if (<#= instVarName #> != null)
                            {
<#
                foreach (var pk in classSpec.Properties.Keys)
                {
                    var propSpec = classSpec.Properties[pk];
                    if (propSpec.Writable)
                    {
                        var attrDef = propSpec.AttrDef;
                        string attrTypeName = DomainDataTypeDefs.GetDataTypeName(DomainDataTypeDefs.GetBaseDT(attrDef));
                        string attrPropName = GeneratorNames.GetAttrPropertyName(attrDef);
#>
                                if (invSpec.Parameters.ContainsKey("<#= pk #>"))
                                {
                                    <#= instVarName #>.<#= attrPropName #> = (<#= attrTypeName #>)invSpec.Parameters["<#= pk #>"];
                                }
<#
                    }
                }
#>
                                updated = true;
                            }
                            break;
<#
            }
        }
#>
                    }              
                }
            }
            if (updated)
            {
                domainModel.InstanceRepository.SyncChangedStates(new List<ChangedState>());
            }
            var result = new { updated = updated };
            return Newtonsoft.Json.JsonConvert.SerializeObject(result);
        }

        public override string GetInstances(string classKeyLett)
        {
            List<Dictionary<string, object>> resultInstances = GetInstancesRaw(classKeyLett);

            return Newtonsoft.Json.JsonConvert.SerializeObject(resultInstances);
        }

        protected List<Dictionary<string, object>> GetInstancesRaw(string classKeyLett)
        {
            var resultInstances = new List<Dictionary<string, object>>();
            if (classSpecs.ContainsKey(classKeyLett))
            {
                var instances = domainModel.InstanceRepository.GetDomainInstances(classKeyLett);
                foreach (var instance in instances)
                {
                    switch (classKeyLett)
                    {
<#
        foreach (var ck in classSpecs.Keys)
        {
            var classSpec = classSpecs[ck];
            string domainClassName = GeneratorNames.GetDomainClassName(classSpec.ObjDef);
            string classKeyLett = classSpec.KeyLetter;
            string instVarName = $"instanceOf{classKeyLett}";
            string resultInstVarName = $"resultOf{instVarName}";
#>
                        case "<#= classKeyLett #>":
                            var <#= instVarName #> = (<#= domainClassName #>)instance;
                            var <#= resultInstVarName #> = new Dictionary<string, object>();
<#
            foreach (var pk in classSpec.Properties.Keys)
            {
                var propSpec = classSpec.Properties[pk];
                var attrDef = propSpec.AttrDef;
                string attrPropName = GeneratorNames.GetAttrPropertyName(attrDef);
#>
                            <#= resultInstVarName #>.Add("<#= pk #>", <#= instVarName #>.<#= attrPropName #>);
<#
            }
#>
                            resultInstances.Add(<#= resultInstVarName #>);
                            break;
<#
    }
#>
                    }
                }
                
            }

            return resultInstances;
        }

        public override string GetInstance(string classKeyLett, IDictionary<string, string> identities)
        {
            Dictionary<string, object> resultInstance = new Dictionary<string, object>();
            switch (classKeyLett)
            {
<#
    foreach (var ck in classSpecs.Keys)
    {
        var classSpec = classSpecs[ck];
        string domainClassName = GeneratorNames.GetDomainClassName(classSpec.ObjDef);
        string classKeyLett = classSpec.KeyLetter;
        string instVarName = $"instanceOf{classKeyLett}";
        string resultInstVarName = $"resultOf{instVarName}";
        string instSelectedCode = GetSelectedByIdentitiesCode(domainClassName, "selected", "identities", classSpec.Properties);
#>
                case "<#= classKeyLett #>":
                    <#= domainClassName #> <#= instVarName #> = (<#= domainClassName #>)domainModel.InstanceRepository.GetDomainInstances("<#= classKeyLett #>").Where(<#= instSelectedCode #>).FirstOrDefault();
                    if (<#= instVarName #> != null)
                    {
<#
        foreach (var pk in classSpec.Properties.Keys)
        {
            var propSpec = classSpec.Properties[pk];
            var attrDef = propSpec.AttrDef;
            string attrPropName = GeneratorNames.GetAttrPropertyName(attrDef);
#>
                        resultInstance.Add("<#= pk #>", <#= instVarName #>.<#= attrPropName #>);
<#
        }
#>
                    }
                    break;
<#
    }
#>
            }
            return Newtonsoft.Json.JsonConvert.SerializeObject(resultInstance);
        }

        public override string GetLinkedInstances(string classKeyLett, IDictionary<string, string> identities, string relName)
        {
            var resultInstances = new List<Dictionary<string, object>>();
            if (classSpecs.ContainsKey(classKeyLett))
            {
                var classSpec = classSpecs[classKeyLett];
                if (classSpec.Links.ContainsKey(relName))
                {
                    switch (classKeyLett)
                    {
<#
    foreach (var ck in classSpecs.Keys)
    {
        var classSpec = classSpecs[ck];
        string domainClassName = GeneratorNames.GetDomainClassName(classSpec.ObjDef);
        string classKeyLett = classSpec.KeyLetter;
        string instVarName = $"instanceOf{classKeyLett}";
        string resultInstVarName = $"resultOf{instVarName}";
        string instSelectedCode = GetSelectedByIdentitiesCode(domainClassName, "selected", "identities", classSpec.Properties);
#>
                        case "<#= classKeyLett #>":
                            <#= domainClassName #> <#= instVarName #> = (<#= domainClassName #>)domainModel.InstanceRepository.GetDomainInstances("<#= classKeyLett #>").Where(<#= instSelectedCode #>).FirstOrDefault();
                            if (<#= instVarName #> != null)
                            {
                                switch (relName)
                                {
<#
        foreach (var lk in classSpec.Links.Keys)
        {
            var linkSpec = classSpec.Links[lk];
            var dstClassKeyLetter = linkSpec.DstKeyLett;
            string dstDomainClassName = GeneratorNames.GetDomainClassName(linkSpec.DstObjDef);
            string relName = $"{linkSpec.RelID}{linkSpec.Side}{GeneratorNames.ToProgramAvailableString(linkSpec.Phrase)}{linkSpec.DstKeyLett}";
            string relInstVarName = $"linkedInstanceOf{relName}";
            string relInstSetVarName = $"linkedInstancesOf{relName}";
            var propSpecs = classSpecs[dstClassKeyLetter].Properties;
#>
                                    case "<#= linkSpec.Name #>":
<#
            if (linkSpec.Set)
            {
#>
                                        var <#= relInstSetVarName #> = <#= instVarName #>.<#= linkSpec.MethodName #>();
                                        foreach (var <#= relInstVarName #> in <#= relInstSetVarName #>)
                                        {
<#
            }
            else
            {
#>
                                        var <#= relInstVarName #> = <#= instVarName #>.<#= linkSpec.MethodName #>();
                                        if (<#= relInstVarName #> != null)
                                        {
<#
            }
#>
                                            resultInstances.Add(new Dictionary<string, object>()
                                            {
<#
            int lpCount = 1;
            foreach (var pk in propSpecs.Keys)
            {
                var propSpec = propSpecs[pk];
                string attrPropName = GeneratorNames.GetAttrPropertyName(propSpec.AttrDef);
#>
                                                { "<#= pk #>", <#= relInstVarName #>.<#= attrPropName #> }<# if (lpCount < propSpecs.Count) { #>,
<# } else { #>

<#
                }
                lpCount++;
            }
#>
                                            });
                                        }
                                        break;
<#
        }
#>
                                }
                            }
                            break;
<#
    }
#>
                    }
                }
            }

            return Newtonsoft.Json.JsonConvert.SerializeObject(resultInstances);
        }

        public override string GetDomainOperationsSpec()
        {
            string result = Newtonsoft.Json.JsonConvert.SerializeObject(domainOpsParamSpecs);
            return result;
        }

        public override string GetClassesSpec()
        {
            string result = Newtonsoft.Json.JsonConvert.SerializeObject(classSpecs);
            return result; 
        }

        public override string GetDomainModelSpec()
        {
            var spec = new {
                name = "<#= nameSpace #>",
                operations = domainOpsParamSpecs,
                classes = classSpecs
            };
            string result = Newtonsoft.Json.JsonConvert.SerializeObject(spec);
            return result;
        }

        public override void RegisterUpdateHandler(ClassPropertiesUpdateHandler classPropertiesUpdateHandler, RelationshipUpdateHandler relationshipUpdateHandler)
        {
            domainModel.InstanceRepository.ClassPropertiesUpdated += classPropertiesUpdateHandler;
            domainModel.InstanceRepository.RelationshipUpdated += relationshipUpdateHandler;
        }

        public override void LoadDomainInstances(string instances)
        {
            string domainName = "<#= nameSpace #>";
            var instancesJson = Newtonsoft.Json.JsonConvert.DeserializeObject<IDictionary<string, IList<IDictionary<string, object>>>>(instances);
            domainModel.InstanceRepository.LoadState(domainName, instancesJson);
        }

        public override string SaveDomainInstances()
        {
            Dictionary<string, List<Dictionary<string, object>>> instances = new Dictionary<string, List<Dictionary<string, object>>>();
            foreach(var ck in classSpecs.Keys)
            {
                var classInstances = GetInstancesRaw(ck);
                if (classInstances.Count > 0)
                {
                    instances.Add(ck, classInstances);
                }
            }
            return Newtonsoft.Json.JsonConvert.SerializeObject(instances);
        }
    }
}
