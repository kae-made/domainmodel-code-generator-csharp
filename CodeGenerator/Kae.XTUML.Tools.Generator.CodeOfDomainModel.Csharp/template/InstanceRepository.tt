<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This file is generated by tool.
//     Runtime Version : <#= version #>
//  
//     Updates this file cause incorrect behavior 
//     and will be lost when the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using Kae.Utility.Logging;

namespace <#= nameSpace #>
{
    public abstract class InstanceRepository
    {
        protected Dictionary<string, List<DomainClassDef>> domainInstances = new Dictionary<string, List<DomainClassDef>>();

        public void Add(DomainClassDef instance)
        {
            if (!domainInstances.ContainsKey(instance.ClassName))
            {
                domainInstances.Add(instance.ClassName, new List<DomainClassDef>());
            }
            domainInstances[instance.ClassName].Add(instance);
        }

        public bool Delete(DomainClassDef instance)
        {
            bool result = false;

            if (domainInstances.ContainsKey(instance.ClassName))
            {
                if (domainInstances[instance.ClassName].Contains(instance))
                {
                    domainInstances[instance.ClassName].Remove(instance);
                    if (domainInstances[instance.ClassName].Count == 0)
                    {
                        domainInstances.Remove(instance.ClassName);
                    }
                    result = true;
                }
            }

            return result;
        }

        public IEnumerable<DomainClassDef> GetDomainInstances(string domainName)
        {
            List<DomainClassDef> result = new List<DomainClassDef>();

            if (domainInstances.ContainsKey(domainName))
            {
                var instances = domainInstances[domainName];
                foreach(var instance in instances)
                {
                    result.Add(instance);
                }
            }

            return result;
        }

        public IList<ChangedState> CreateChangedStates()
        {
            return new List<ChangedState>();
        }

        public void SyncChangedStates(IList<ChangedState> changedStates)
        {
            lock (domainInstances)
            {
                foreach (var changedState in changedStates)
                {
                    if (changedState is CInstanceChagedState)
                    {
                        UpdateCInstance((CInstanceChagedState)changedState);
                    }
                    else if (changedState is CLinkChangedState)
                    {
                        UpdateCLink((CLinkChangedState)changedState);
                    }
                }
                foreach (var className in domainInstances.Keys)
                {
                    foreach (var instance in domainInstances[className])
                    {
                        var updatedState = instance.ChangedProperties();
                        UpdateState(instance, updatedState);
                    }
                }
            }
        }

        public void UpdateState()
        {
            foreach (var className in domainInstances.Keys)
            {
                foreach (var instance in domainInstances[className])
                {
                    var changedStates = instance.ChangedProperties();
                    UpdateState(instance, changedStates);
                }
            }
        }

        ///
        /// Update stored state of the instance by changed argument.
        /// changed.key is name of property of the instance.
        /// changed.value is value of the property that the name of it  is changed.key
        ///
        public abstract void UpdateState(DomainClassDef instance, IDictionary<string, object> chnaged);

        ///
        /// Construct state of the instances by instances argument.
        /// instances.key is domain class name.
        /// instances.value is instances states of the domain class.
        /// each item of the instances.value is property name and value pairs.
        ///
        public abstract void LoadState(IDictionary<string, IList<IDictionary<string, object>>> instances);

        public abstract void UpdateCInstance(CInstanceChagedState instanceState);
        public abstract void UpdateCLink(CLinkChangedState linkState);

        public abstract IEnumerable<T> SelectInstances<T>(string className, IDictionary<string, object> conditionPropertyValues, Func<T, IDictionary<string, object>, bool> compare) where T : DomainClassDef;

    }

    public abstract class ChangedState
    {
        public enum Operation
        {
            Create,
            Update,
            Delete
        }

        public Operation OP { get; set; }
    }

    public class CInstanceChagedState : ChangedState
    {
        public DomainClassDef Target { get; set; }
        public IDictionary<string, object> ChangedProperties { get; set; }
    }

    public class CLinkChangedState : ChangedState
    {
        public LinkedInstance Target { get; set; }
    }

    public class InstanceRepositoryInMemory : InstanceRepository
    {
        private Logger logger;

        public InstanceRepositoryInMemory(Logger logger)
        {
            this.logger = logger;
        }

        public override void UpdateState(DomainClassDef instance, IDictionary<string, object> chnaged)
        {
            // Do nothing.
        }

        public override void LoadState(IDictionary<string, IList<IDictionary<string, object>>> instances)
        {
            foreach (var className in instances.Keys)
            {
                foreach (var states in instances[className])
                {
                    DomainClassDef newInstance = null;
                    switch (className)
                    {
<#
    foreach(var objDef in objDefs)
    {
        string domainClassBaseName = GeneratorNames.GetDomainClassImplName(objDef);
        string domainClassName = objDef.Attr_Key_Lett;
#>
                        case "<#= domainClassName #>":
                            newInstance = <#= domainClassBaseName #>.CreateInstance(this, logger);
                            break;
<#
    }
#>
                        default:
                            if (logger != null) logger.LogError($"{className} is not right domain class.");
                            break;
                    }
                    if (newInstance != null)
                    {
                        newInstance.Restore(states);
                    }
                }
            }
        }

        public override void UpdateCInstance(CInstanceChagedState instanceState)
        {
            // Do nothing
        }

        public override void UpdateCLink(CLinkChangedState linkState)
        {
            // To nothing
        }

        public override IEnumerable<T> SelectInstances<T>(string className, IDictionary<string, object> conditionPropertyValues, Func<T, IDictionary<string, object>, bool> compare)
        {
            var resultSet = new List<T>();
            var candidates = domainInstances[className].Where(i => { return compare((T)i, conditionPropertyValues); });
            foreach (var ci in candidates)
            {
                resultSet.Add((T)ci);
            }
            return resultSet;
        }

    }

}
